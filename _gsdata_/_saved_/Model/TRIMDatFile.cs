using System;
using System.Collections.ObjectModel;
using System.IO;
using TRIM_Helper.Model.LayerModel;
using TRIM_Helper.Model.LayerModel.MaterialModel;

namespace TRIM_Helper.Model
{
    public class TRIMDatFile
    {
        public string FilePath;
        public string IonRowName;
        public string CalcComment;
        public int IonsCount { get; set; } = 10000;
        public int DecimalPoints { get; set; } = 5;

        public double IonStartX { get; set; } = 0.0;
        public double IonStartY { get; set; } = 0.0;
        public double IonStartZ { get; set; } = 0.0;
        public double IonStartCosX { get; set; } = 1.0;
        public double IonStartCosY { get; set; } = 0.0;
        public double IonStartCosZ { get; set; } = 0.0;

        //Random Flags
        public bool IsRandomX { get; set; } = true;
        public bool IsRandomY { get; set; } = true;
        public bool IsRandomZ { get; set; } = true;
        public bool IsRandomCosX { get; set; } = true;
        public bool IsRandomCosY { get; set; } = true;
        public bool IsRandomCosZ { get; set; } = true;

        /// <summary>
        /// Define incidence angle limits
        /// </summary>
        public AngleLimits Angles;

        /// <summary>
        /// Array of Start Locations and Directions of Ion
        /// </summary>
        public IonLocAndDir[] IonsPos;

        public IonTarget Target;

        public TRIMDatFile()
        {
            
        }

        public double GenerateRandomIn(double MaxValue, double MinValue = 0)
        {
            Random rnd = new Random();
            return rnd.NextDouble() * (MaxValue - MinValue) + MinValue;
        }

        public void GenerateDataFile(string FilePath, Ion Ions, ObservableCollection<TargetLayer> Layers, IProgress<int> progress, bool IsOutData, string OutDataPath = null)
        {
            if (Ions == null)
            {
                throw new Exception("Empty Ions List");
            }
            if (Layers == null || Layers.Count < 1)
                throw new Exception("Empty layers list");

            FilePath = (!string.IsNullOrEmpty(FilePath)) ? FilePath + "TRIM.dat" : "TRIM.dat";
            double sumWidth = 0;
            if (!IsOutData)
            {
                GeneratePositions(Ions.Energy);
                GenerateAngles();
            }
            else if (!string.IsNullOrEmpty(OutDataPath))
            {
                IonsPos = MiscelaniousFunctions.Read_TRANSMITT_File(OutDataPath, progress);
            }

            var linesCount = IonsPos.Length;

            using (StreamWriter writer = new StreamWriter(FilePath))
            {
                double sizeMax = Math.Round(sumWidth / 2.0, 0);
                double sizeMin = -sizeMax;
                //Writing the first 10 lines
                var bufString = "----- TRIM with various Incident Ion Energies/Angles and Depths -----\r\n" +
                                "This files was generated by TRIM Input Generator\r\n" +
                                "Created at " + DateTime.Now + "\r\n" +
                                "Target Dimensions (Anstrom):\r\n" +
                                $"X: (0,{Layers[0].Depth})\tY: ({sizeMin},{sizeMax})\tZ:({sizeMin},{sizeMax})\r\n" +
                                "Angle Limits:\r\n" +
                                $"Zenith: ({Angles.Zenith.Min},{Angles.Zenith.Max})\tAzimuth: ({Angles.Azimuth.Min},{Angles.Azimuth.Max})\r\n" +
                                CalcComment + "\r\n" +
                                $"Ions Count: {linesCount}\r\n";

                bufString += string.Format("{0,-7}{1,-5}{2,15}{3,20}{4,20}{5,20}{6,15}{7,15}{8,15}",
                    "Name", "Z", "Energy(eV)", "Depth(A)", "Left(A)", "Right(A)", "Cos(x)", "Cos(y)", "Cos(z)");
                writer.WriteLine(bufString);

                //Start writing data
                for (int row = 0; row < linesCount; row++)
                {
                    string outString = string.Format(
                            "{0,-7}{1,-5}{2,15}{3,20:F" + DecimalPoints + "}{4,20:F" + DecimalPoints + "}{5,20:F" + DecimalPoints + "}{6,15:F" + DecimalPoints + "}{7,15:F" + DecimalPoints + "}{8,15:F" + DecimalPoints + "}",
                            IonRowName,
                            Ions.Z,
                            IonsPos[row].Energy,
                            IonsPos[row].X,
                            IonsPos[row].Y,
                            IonsPos[row].Z,
                            IonsPos[row].CosX,
                            IonsPos[row].CosY,
                            IonsPos[row].CosZ);
                    writer.WriteLine(outString);
                    progress?.Report(100 * row / linesCount);

                }

                //MessageBox.Show("Job done!", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
            }

        }
        public void GeneratePositions(double ionEnergy)
        {
            IonsPos = new IonLocAndDir[IonsCount];
            double LayerDepth = Target.Depth.Max - Target.Depth.Min;
            double LayerWidth = Target.Width.Max - Target.Width.Min;

            double sizeHalfMax = Math.Round(LayerWidth / 2.0, 0);
            double sizeHalfMin = -sizeHalfMax;
            for (int i = 0; i < IonsCount; i++)
            {
                //Additionally add energy definision
                IonsPos[i].Energy = ionEnergy * 1000.0;
                IonsPos[i].X = (IsRandomX) ? GenerateRandomIn(LayerDepth, 0.0) : IonStartX;
                IonsPos[i].Y = (IsRandomY) ? GenerateRandomIn(sizeHalfMax, sizeHalfMin) : IonStartY;
                IonsPos[i].Z = (IsRandomZ) ? GenerateRandomIn(sizeHalfMax, sizeHalfMin) : IonStartZ;
            }
        }

        public void GenerateAngles()
        {
            int ionCount = IonsPos.Length;
            for (int i = 0; i < ionCount; i++)
            {
                var rndZenith = GenerateRandomIn(Angles.Zenith.Max, Angles.Zenith.Min);
                var rndAzimuth = GenerateRandomIn(Angles.Azimuth.Max, Angles.Azimuth.Min);
                IonsPos[i].CosX = (IsRandomCosX) ? Math.Cos(rndZenith) : IonStartCosX;
                IonsPos[i].CosY = (IsRandomCosY) ? Math.Sin(rndZenith) * Math.Sin(rndAzimuth) : IonStartCosY;
                IonsPos[i].CosZ = (IsRandomCosZ) ? Math.Sin(rndZenith) * Math.Cos(rndAzimuth) : IonStartCosZ;
            }
        }
    }
}
